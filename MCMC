import numpy as np
import matplotlib.pyplot as plt
import time
from matplotlib.gridspec import GridSpec
from matplotlib.ticker import PercentFormatter

# Importa do arquivo do problema direto
from problema_direto_mcmc import pseudo_dados, u_of_t, problema_direto_solve
from problema_direto_mcmc import N, w 
import warnings
warnings.filterwarnings("ignore", category=RuntimeWarning)

# --- CONFIGURAÇÃO GLOBAL ---
plt.rcParams.update({
    "text.usetex": False, 
    "font.family": "serif",
    "font.serif": ["DejaVu Serif", "Bitstream Vera Serif", "Computer Modern Roman"],
    "font.size": 12
})

# --- FUNÇÃO AUXILIAR: DETECÇÃO AUTOMÁTICA DE BURN-IN ---
def detectar_burn_in(L_history, window_size=20):
    # # Atualizado para 10% conforme solicitado
    # tail_size = max(int(len(L_history) * 0.10), 10)
    # tail_data = L_history[-tail_size:]
    # target_mean = np.mean(tail_data)
    # target_std = np.std(tail_data)
    # tolerance = 1.0 * target_std 
    # for i in range(0, len(L_history) - tail_size):
    #     current_window = L_history[i : i + window_size]
    #     if len(current_window) < window_size: break
    #     window_mean = np.mean(current_window)
    #     if np.abs(window_mean - target_mean) < tolerance: return i 
    return int(len(L_history) * 0.5)

# --- FUNÇÃO NOVA: DIAGNÓSTICO DE GEWEKE ---
def geweke_diagnostic(chain, first_perc=0.1, last_perc=0.5):
    """
    Aplica o teste de Geweke na cadeia JÁ CORTADA (sem burn-in).
    Retorna o Z-score para cada parâmetro.
    """
    n = chain.shape[0]
    n_a = int(n * first_perc)
    n_b = int(n * last_perc)
    
    if n_a < 10 or n_b < 10:
        return np.full(chain.shape[1], np.nan)

    part_a = chain[:n_a, :]
    part_b = chain[-n_b:, :]
    
    mean_a = np.mean(part_a, axis=0)
    mean_b = np.mean(part_b, axis=0)
    
    # Variância (Erro Padrão da Média)
    var_a = np.var(part_a, axis=0) / n_a
    var_b = np.var(part_b, axis=0) / n_b
    
    z_score = (mean_a - mean_b) / np.sqrt(var_a + var_b)
    return z_score

# --- 1. Proposta Conjunta ---
def propor_estado(u_atual, params_atual, sigma_u, sigma_params):
    u_novo = u_atual + np.random.normal(0, sigma_u, size=len(u_atual))
    params_novo = np.array(params_atual) + np.random.normal(0, sigma_params, size=3)
    return u_novo, params_novo

# --- 2. Probabilidade Posterior (COM TRUNCAMENTO) ---
def log_posterior(u, params, Y1, Y2, sigma_noise, gamma, priori_medias, priori_stds, trunc_nsigma):
    P2, P3, P4 = params
    
    # 1. GUARDA DE DOMÍNIO FÍSICO BÁSICO
    if P2 <= 1e-6 or P3 <= 1e-6 or P4 <= 1e-6:
        return -np.inf
    # 2. APLICAÇÃO DA GAUSSIANA TRUNCADA (HARD CONSTRAINTS)
    for val, mu, sig in zip(params, priori_medias, priori_stds):
        delta_limit = trunc_nsigma * sig
        # Se tentar sair da cerca, REJEITA (retorna -inf).
        if val < (mu - delta_limit) or val > (mu + delta_limit):
            return -np.inf    
    # 3. SOLUÇÃO DO PROBLEMA DIRETO
    try:
        T1_calc, T2_calc = problema_direto_solve(u, P2, P3, P4)
    except RuntimeWarning:
        return -np.inf

    # 4. GUARDA DE ESTABILIDADE NUMÉRICA
    if np.any(np.isnan(T1_calc)) or np.any(np.isinf(T1_calc)):
        return -np.inf
    if np.any(np.isnan(T2_calc)) or np.any(np.isinf(T2_calc)):
        return -np.inf

    # 5. CÁLCULO PADRÃO
    min_len = min(len(Y1), len(T1_calc))
    
    # Likelihood
    sse = np.sum((T1_calc[:min_len] - Y1[:min_len])**2) + np.sum((T2_calc[:min_len] - Y2[:min_len])**2)
    log_lik = - sse / (2 * sigma_noise**2)
    
    # Prior u(t): Total Variation
    derivada = np.diff(u)
    log_prior_u = - gamma * np.sum(np.abs(derivada))
    
    # Prior Parâmetros: Gaussianas (Soft Constraint)
    log_prior_p = 0
    for val, mu, sig in zip(params, priori_medias, priori_stds):
        log_prior_p += -0.5 * ((val - mu) / sig)**2
        
    return log_lik + log_prior_u + log_prior_p

# --- 3. MCMC ---
def MH(times, Y1, Y2, iterations, sigma_step_u, sigma_step_params, gamma, priori_info, trunc_nsigma):
    u = np.zeros(N)
    sigma_noise = w
    priori_medias, priori_stds = priori_info
    params = np.array(priori_medias, dtype=float)
    
    log_curr = log_posterior(u, params, Y1, Y2, sigma_noise, gamma, priori_medias, priori_stds, trunc_nsigma)
    
    chain_u, chain_params = [], []
    L_history, Acc_history, Iter_history = [], [], []
    accepted_count = 0
    
    print(f"Iniciando MCMC... Params: Iter={iterations}, Gamma={gamma}, Trunc={trunc_nsigma}s")
    
    for i in range(iterations + 1):
        u_star, params_star = propor_estado(u, params, sigma_step_u, sigma_step_params)
        log_star = log_posterior(u_star, params_star, Y1, Y2, sigma_noise, gamma, priori_medias, priori_stds, trunc_nsigma)
        log_alpha = log_star - log_curr
        
        if log_alpha > 0 or np.log(np.random.rand()) < log_alpha:
            u, params, log_curr = u_star, params_star, log_star
            accepted_count += 1
            
        chain_u.append(u)
        chain_params.append(params)
        
        if i % 500 == 0:
            current_acc = accepted_count / (i + 1)
            L_history.append(log_curr)
            Acc_history.append(current_acc)
            Iter_history.append(i)
            if i % 10000 == 0: 
                print(f"Iter {i}: L={log_curr:.2e} | Acc={current_acc:.1%}")

    return np.array(chain_u), np.array(chain_params), np.array(L_history), np.array(Acc_history), np.array(Iter_history)

# --- FUNÇÃO: LABELS ---
def add_bottom_labels(axes):
    labels = ['(a)', '(b)', '(c)', '(d)']
    offsets = [-0.15, -0.15, -0.30, -0.075]
    for i, ax in enumerate(axes):
        if i < len(labels):
            ax.text(0.5, offsets[i], labels[i], transform=ax.transAxes,
                    fontsize=14, fontweight='bold', va='top', ha='center')

# --- Main ---
# --- Main ---
def main(ITERACOES, SIGMA_U, SIGMA_PARAMS, GAMMA, PRIORI_INFO, TRUNC_NSIGMA, RW_MULTIPLIER):
    times, Y1_medido, Y2_medido = pseudo_dados()
    
    start_time = time.time()
    chain_u, chain_p, L_hist, Acc_hist, Iter_hist = MH(
        times, Y1_medido, Y2_medido, 
        iterations=ITERACOES, sigma_step_u=SIGMA_U, sigma_step_params=SIGMA_PARAMS,
        gamma=GAMMA, priori_info=PRIORI_INFO, trunc_nsigma=TRUNC_NSIGMA
    )
    end_time = time.time()
    exec_time_seconds = end_time - start_time
    
    # 1. Burn-in
    burn_in_L_idx = detectar_burn_in(L_hist)
    idx_safe = min(burn_in_L_idx, len(Iter_hist) - 1)
    real_burn_in_idx = Iter_hist[idx_safe]
    calc_burn_in_ratio = real_burn_in_idx / ITERACOES
    
    chain_u_valid = chain_u[real_burn_in_idx:]
    chain_p_valid = chain_p[real_burn_in_idx:]
    
    # 2. Geweke
    z_scores = geweke_diagnostic(chain_p_valid)
    max_z = np.max(np.abs(z_scores)) if not np.any(np.isnan(z_scores)) else 99.9
    
    u_estimado = np.mean(chain_u_valid, axis=0)
    p_estimado_mean = np.mean(chain_p_valid, axis=0) 

    # --- CÁLCULO DO ERRO PERCENTUAL ---
    # Definindo os valores reais conhecidos para P2, P3, P4
    P_REAL = np.array([0.25, 15.0, 0.30])
    
    # Cálculo do erro percentual absoluto
    p_errors_perc = np.abs((p_estimado_mean - P_REAL) / P_REAL) * 100
    
    u_lower = np.percentile(chain_u_valid, 2.5, axis=0)
    u_upper = np.percentile(chain_u_valid, 97.5, axis=0)
    L_final_mean = np.mean(L_hist[idx_safe:])
    
    u_real = np.array([u_of_t(t) for t in times[:-1]])
    T1_final, T2_final = problema_direto_solve(u_estimado, *p_estimado_mean)
    
    # --- PLOTAGEM ---
    COLOR_T1, COLOR_T2 = '#083464', '#880424'
    fig = plt.figure(figsize=(14, 11)) 
    gs = GridSpec(3, 2, figure=fig, width_ratios=[1, 1.2], hspace=0.35) 
    
    ax1 = fig.add_subplot(gs[0, 0])
    ax2 = fig.add_subplot(gs[1, 0], sharex=ax1)
    ax3 = fig.add_subplot(gs[2, 0], sharex=ax1)
    ax4 = fig.add_subplot(gs[0:2, 1]) 
    ax_text = fig.add_subplot(gs[2, 1])
    ax_text.axis('off')
    
    ax1.plot(times, Y1_medido, '.', color=COLOR_T1, markersize=4, alpha=0.4, label='Medidas')
    ax1.plot(times, T1_final, '-', color=COLOR_T1, linewidth=2, label='Estimado')
    ax1.set_ylabel('T1 (°C)')
    ax1.legend(loc='upper right', fontsize=12, framealpha=0.9)
    ax1.grid(True, alpha=0.3)
    
    ax2.plot(times, Y2_medido, '.', color=COLOR_T2, markersize=4, alpha=0.4, label='Medidas')
    ax2.plot(times, T2_final, '-', color=COLOR_T2, linewidth=2, label='Estimado')
    ax2.set_ylabel('T2 (°C)')
    ax2.legend(loc='upper right', fontsize=12, framealpha=0.9)
    ax2.grid(True, alpha=0.3)
    
    ax3.plot(times[:-1], u_real, '-', color='dimgray', linewidth=3.0, label='Exato') 
    ax3.plot(times[:-1], u_estimado, 'k-', linewidth=1.5, label='Estimado')
    ax3.fill_between(times[:-1], u_lower, u_upper, color='gray', alpha=0.4, label='IC 95%')
    ax3.set_ylabel('Fonte u(t)')
    
    ax3.set_xlabel('Tempo (s)', loc='center')
    ax3.legend(loc='lower right', fontsize=12, framealpha=0.9)
    ax3.grid(True, alpha=0.3)
    
    ax_L, ax_Acc = ax4, ax4.twinx()
    color_L, color_Acc = 'black', 'gray'
    
    L_plot_data = np.abs(L_hist) / 1000.0
    Iter_plot_data = Iter_hist / 1000.0 
    
    lns1 = ax_L.plot(Iter_plot_data, L_plot_data, color=color_L, linewidth=1.5, label='||Log-Posterior||')
    ax_L.set_ylabel(r'||Log-Posterior|| ($\times 10^3$)', color=color_L)
    ax_L.set_xlabel(r'Iterações ($\times 10^3$)', loc='center')
    ax_L.tick_params(axis='y', colors=color_L)
    
    lns2 = ax_Acc.plot(Iter_plot_data, Acc_hist, color=color_Acc, linewidth=1.5, label='Taxa de Aceitação')
    ax_Acc.set_ylabel('Taxa de Aceitação', color=color_Acc)
    ax_Acc.tick_params(axis='y', colors=color_Acc)
    ax_Acc.yaxis.set_major_formatter(PercentFormatter(1.0))
    ax_Acc.set_ylim(0, 1.0)
    
    real_burn_in_scaled = real_burn_in_idx / 1000.0
    line_burnin = ax_L.axvline(x=real_burn_in_scaled, color='k', linestyle='--', alpha=0.5, label='Corte do Burn-in')
    ax_L.axvspan(0, real_burn_in_scaled, color='gray', alpha=0.15)
    
    lns = lns1 + lns2 + [line_burnin]
    labs = [l.get_label() for l in lns]
    ax_L.legend(lns, labs, loc='upper right', fontsize=12, framealpha=0.9)
    ax_L.grid(True, alpha=0.3)

    add_bottom_labels([ax1, ax2, ax3, ax4])

    # --- TABELA ---
    m, s = divmod(exec_time_seconds, 60)
    time_str = f"{int(m)}m {int(s)}s"
    iter_str = f"{ITERACOES/1000:.0f} x10³"
    burn_perc = int(calc_burn_in_ratio*100)
    
    mu_p, sigma_p = PRIORI_INFO
    trunc_str = f"{TRUNC_NSIGMA} x σ"
    
    geweke_str = f"Max |Z|={max_z:.2f}"
    if max_z < 2.0: geweke_str += " (OK)"
    else: geweke_str += " (Fail)"
    
    dados_input = [
        ('Gamma', str(GAMMA)),
        ('RW Passo u(t)', str(SIGMA_U)),
        ('RW Passo P.', f"{RW_MULTIPLIER} x μ"),
        ('Iterações', iter_str),
        ('Burn-in', f'{burn_perc}%'),
        ('Truncamento', trunc_str),
        # ('Geweke Diag', geweke_str),
        ('P2 Prior', f'N({mu_p[0]:.2f}, {sigma_p[0]:.3f})'),
        ('P3 Prior', f'N({mu_p[1]:.1f}, {sigma_p[1]:.3f})'),
        ('P4 Prior', f'N({mu_p[2]:.2f}, {sigma_p[2]:.3f})'),
    ]
    
    # Função auxiliar para formatar valor e erro
    def fmt_val_err(val, err):
        return f"{val:.3f} (erro {err:.1f}%)"

    dados_output = [
        ('P2 Est.', fmt_val_err(p_estimado_mean[0], p_errors_perc[0])),
        ('P3 Est.', fmt_val_err(p_estimado_mean[1], p_errors_perc[1])),
        ('P4 Est.', fmt_val_err(p_estimado_mean[2], p_errors_perc[2])),
        ('L Final', f'{L_final_mean:.2e}'),
        ('Tempo', time_str)
    ]
    
    # AUMENTEI W2 PARA ACOMODAR O TEXTO EXTRA
    W1, W2 = 13, 24
    SEP_V = "│"
    SEP_MID = " ║ "
    LINE_L = "─" * (W1 + 3 + W2)
    LINE_R = "─" * (W1 + 3 + W2)
    
    def fmt_cell(label, val):
        return f"{label:>{W1}} {SEP_V} {val:<{W2}}"

    header = f"{'INPUTS':^{len(LINE_L)}}{SEP_MID}{'OUTPUTS':^{len(LINE_R)}}"
    subhead = f"{fmt_cell('Param.', 'Valor')}{SEP_MID}{fmt_cell('Param.', 'Valor')}"
    separator = f"{LINE_L}{SEP_MID}{LINE_R}"
    
    body_lines = []
    max_rows = max(len(dados_input), len(dados_output))
    
    for i in range(max_rows):
        if i < len(dados_input):
            l_lbl, l_val = dados_input[i]
            left_txt = fmt_cell(l_lbl, l_val)
        else:
            left_txt = " " * (W1 + 3 + W2)
            
        if i < len(dados_output):
            r_lbl, r_val = dados_output[i]
            right_txt = fmt_cell(r_lbl, r_val)
        else:
            right_txt = " " * (W1 + 3 + W2)
            
        body_lines.append(f"{left_txt}{SEP_MID}{right_txt}")
        
    texto_final = f"{header}\n{subhead}\n{separator}\n" + "\n".join(body_lines)
    
    ax_text.text(0.5, 0.5, texto_final, 
                 fontsize=9, 
                 fontname='DejaVu Sans Mono', 
                 verticalalignment='center',
                 horizontalalignment='center',
                 bbox=dict(boxstyle="round,pad=0.8", facecolor="white", edgecolor="gray", alpha=0.9))
    
    plt.subplots_adjust(bottom=0.08, hspace=0.4)

    mu_str = f"{mu_p[0]}-{mu_p[1]}-{mu_p[2]}"
    sigma_str = f"{sigma_p[0]:.3f}-{sigma_p[1]:.3f}-{sigma_p[2]:.3f}"
    filename = f"MCMC_iter={int(ITERACOES/1000)}k_gamma={GAMMA}_sigma={SIGMA_U}_mu={mu_str}_dp={sigma_str}_trunc={TRUNC_NSIGMA}sigma.png"
    
    plt.savefig(filename, dpi=100, bbox_inches='tight')
    print(f"\nGráfico salvo como: {filename}")
    plt.close(fig)
    
if __name__ == "__main__":
    priori_medias = [0.25, 15.0, 0.3]
    # Gaussiana da Prior
    priori_stds   = [priori_medias[0]*0.02, priori_medias[1]*0.02, priori_medias[2]*0.02]
    
    # --- CONFIGURAÇÃO DA BATELADA ---
    # Estrutura: (Iter, Sigma_U, Sigma_Params, Gamma, Priori_Info, Truncation_Sigmas, Multiplier_RW)
    
    TRUNC_DEFAULT = 1.96 # 99% CI
    lista = []

    # Configuração solicitada
    mult_1 = 0.001
    sigma_params_1 = [m * mult_1 for m in priori_medias]
    lista.append((1_000, 0.0030, sigma_params_1, 50, (priori_medias, priori_stds), TRUNC_DEFAULT, mult_1))
    # lista.append((100_000, 0.0030, sigma_params_1, 100, (priori_medias, priori_stds), TRUNC_DEFAULT, mult_1))
    # lista.append((100_000, 0.0030, sigma_params_1, 200, (priori_medias, priori_stds), TRUNC_DEFAULT, mult_1))
    # lista.append((100_000, 0.0020, sigma_params_1, 50, (priori_medias, priori_stds), TRUNC_DEFAULT, mult_1))
    # lista.append((100_000, 0.0010, sigma_params_1, 50, (priori_medias, priori_stds), TRUNC_DEFAULT, mult_1))


    print(f"Iniciando batelada de {len(lista)} simulações...")
    for i, params in enumerate(lista):
        print(f"\n--- Simulação {i+1}/{len(lista)} ---")
        main(*params)